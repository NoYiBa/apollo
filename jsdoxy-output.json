{
    "api": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "api"
                }
            ],
            "description": {
                "full": "<p>Router attached at <code>/api</code>.</p>\n",
                "summary": "<p>Router attached at <code>/api</code>.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var router = express.Router();\nvar config = require('../config');\nvar middleware = require('../lib/middleware');\nvar async = require('async');",
            "ctx": {
                "type": "declaration",
                "name": "api",
                "value": "express.Router()",
                "string": "router",
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>GET /me</p>\n<p>Get my Account. Also good for checking if you are logged in.</p>\n",
                "summary": "<p>GET /me</p>\n",
                "body": "<p>Get my Account. Also good for checking if you are logged in.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Account || null",
            "ignore": false,
            "code": "router.get('/me', function (req, res, next) {\n    if (!req.user) {\n        return res.send(req.user);\n    }\n    req.db.Account.findById(req.user._id).exec(function (err, account) {\n        if (err) {\n            return next(err);\n        }\n        res.send(account);\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "password",
                    "description": ""
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "display",
                    "description": ""
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "email",
                    "description": ""
                },
                {
                    "type": "arg",
                    "types": [
                        "object"
                    ],
                    "name": "settings",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>PATCH /me</p>\n<p>Update my own account. All body properties are optional.</p>\n",
                "summary": "<p>PATCH /me</p>\n",
                "body": "<p>Update my own account. All body properties are optional.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Account",
            "ignore": false,
            "code": "router.patch('/me', middleware.isAuthorized, function (req, res, next) {\n    var updateFields = {};\n    ['password', 'display', 'email', 'settings'].forEach(function (field) {\n        if (req.body[field]) {\n            updateFields[field] = req.body[field];\n        }\n    });\n    if (!Object.keys(updateFields).length) {\n        return res.send(req.user);\n    }\n    req.db.Account.findById(req.user._id).exec(function (err, account) {\n        if (err) {\n            return next(err);\n        }\n        for (var f in updateFields) {\n            account[f] = updateFields[f]\n        }\n        var settings = account.settings;\n        account.save(function (err, saved) {\n            if (err) {\n                return next(err);\n            }\n            saved = saved.toObject();\n            saved.settings = settings; // these are normally excluded\n            res.send(saved);\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>PUT /forgot/:emailOrId</p>\n<p>Forgot password.</p>\n",
                "summary": "<p>PUT /forgot/:emailOrId</p>\n",
                "body": "<p>Forgot password.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object { message: \"\" }",
            "ignore": false,
            "code": "router.put('/forgot/:emailOrId', function (req, res, next) {\n    if (!req.params.emailOrId) {\n        return res.send(400, { error: \"Missing identifier for password reset. Need email or account ID.\" });\n    }\n    req.db.Account.findOne()\n    .or([{ email: req.params.emailOrId }, { _id: req.params.emailOrId }])\n    .select('+conf')\n    .exec(function (err, account) {\n        if (err) {\n            return next(err);\n        }\n\n        if (account.conf && account.conf.slice(0, 7) === 'confirm') {\n            return res.status(400).send({\n                message: \"Your account must be confirmed before you may reset your password.\"\n            });\n        }\n\n        var message = { message: 'A password reset has been requested. Check your email.' };\n        // give no indication if the email was wrong\n        if (!account || !account.email) {\n            return res.send(message);\n        }\n\n        account.passwordReset(function (err, acct) {\n            if (err) {\n                req.log.error(err);\n                return next(err);\n            }\n\n            // send an e-mail\n            req.email.sendMail({\n                from: config.email.from,\n                to: acct.email,\n                subject: 'Password reset - ' + config.name,\n                text: 'Visit the following link to reset your ' + config.name + ' password.\\n\\n'\n                    + config.baseURL + '/password-reset/' + acct._id + '/' + acct.conf\n            }, function (err) {\n                if (err) {\n                    req.log.error(err);\n                    return next(err);\n                }\n                res.send(message);\n            });\n\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "password",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>PUT /password-reset/:_id/:conf</p>\n<p>Reset password using confirmation token.</p>\n",
                "summary": "<p>PUT /password-reset/:_id/:conf</p>\n",
                "body": "<p>Reset password using confirmation token.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Account",
            "ignore": false,
            "code": "router.put('/password-reset/:_id/:conf', function (req, res, next) {\n    req.db.Account\n    .findOne({ _id: req.params._id, conf: req.params.conf })\n    .select('+conf')\n    .exec(function (err, account) {\n        if (err) {\n            return next(err);\n        }\n        if (!account) {\n            return res.send(404);\n        }\n        var passCheckFail = account.isPasswordInvalid(req.body.password);\n        if (passCheckFail) {\n            return res.send(400, { error: passCheckFail });\n        }\n        account.password = req.body.password;\n        account.conf = null;\n        account.save(function (err, saved) {\n            if (err) {\n                return next(err);\n            }\n            req.login(saved, function (err) {\n                if (err) {\n                    return next(err);\n                }\n                res.send(saved);\n            });\n\n            // notify people that their password was reset\n            req.email.sendMail({\n                from: config.email.from,\n                to: account.email,\n                subject: 'Your ' + config.name + ' password was reset',\n                text: 'This is a notification that the password has been reset on your ' + config.name + ' account.'\n            }, function (err) {\n                if (err) {\n                    req.log.error(err);\n                }\n            });\n\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>GET /accounts</p>\n<p>List all accounts.</p>\n",
                "summary": "<p>GET /accounts</p>\n",
                "body": "<p>List all accounts.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "Array of Accounts",
            "ignore": false,
            "code": "router.get('/accounts', middleware.isAuthorized, function (req, res, next) {\n    var query = req.db.Account.find().select('+conf').lean();\n\n    if (req.query.ids && typeof req.query.ids === 'string') {\n        query\n        .where('_id').in(req.query.ids.split(','))\n        .exec(handler);\n    }\n    else {\n        query.exec(handler);\n    }\n    function handler(err, accounts) {\n        if (err) {\n            return next(err);\n        }\n        accounts.forEach(function (acct) {\n            if (acct.conf && acct.conf.slice(0, 5) === 'reset') {\n                delete acct.conf;\n            }\n            if (!acct.conf) {\n                delete acct.conf;\n            }\n            delete acct.settings;\n        });\n        res.send(accounts);\n    }\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>GET /accounts/:id</p>\n<p>Fetch a specific account.</p>\n",
                "summary": "<p>GET /accounts/:id</p>\n",
                "body": "<p>Fetch a specific account.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Account",
            "ignore": false,
            "code": "router.get('/accounts/:id', middleware.isAuthorized, function (req, res, next) {\n    req.db.Account.findById(req.params.id).select('+conf').exec(function (err, account) {\n        if (err) {\n            return next(err);\n        }\n        if (!account) {\n            return res.status(404).send({ error: 'Account not found by id ' + req.params.id });\n        }\n        res.send(account);\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>DELETE /account/:id</p>\n<h4 id=\"todo-rework-this\">TODO: rework this</h4>\n<p>Remove an account. Does not delete all of their messages/files so may cause breakage or\norphan data.</p>\n",
                "summary": "<p>DELETE /account/:id</p>\n",
                "body": "<h4 id=\"todo-rework-this\">TODO: rework this</h4>\n<p>Remove an account. Does not delete all of their messages/files so may cause breakage or\norphan data.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object { message: \"\" }",
            "ignore": false,
            "code": "router.delete('/accounts/:id', middleware.isAuthorized, function (req, res, next) {\n    req.db.Account.remove({ _id: req.params.id }).exec(function (err) {\n        if (err) {\n            return next(err);\n        }\n        res.send({ message: 'Account was removed.'});\n\n        req.respoke.groups.publish({\n            groupId: config.systemGroupId,\n            message: JSON.stringify({\n                meta: {\n                    type: 'removeaccount',\n                    value: req.params.id\n                }\n            })\n        }, function (err) {\n            if (err) {\n                req.log.error('failed to send delete account notification', err);\n            }\n        });\n    });\n    req.db.Message.remove({ from: req.params.id });\n    req.db.File.remove({ owner: req.params.id });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "_id",
                    "description": "The username and unique identifier and endpoint."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "email",
                    "description": ""
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "display",
                    "description": "The display name for this user."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "password",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>POST /accounts</p>\n<p>Create a new local account and kick off confirmation by email (if required by configuration).</p>\n",
                "summary": "<p>POST /accounts</p>\n",
                "body": "<p>Create a new local account and kick off confirmation by email (if required by configuration).</p>\n"
            },
            "isPrivate": false,
            "fires": [
                "newaccount"
            ],
            "returns": "object Account, { error: \"\" }",
            "ignore": false,
            "code": "router.post('/accounts', function (req, res, next) {\n    if (!config.localSignupEnabled) {\n        return res.status(403).send({\n            error: 'Local account signups are disabled by the system administrator.'\n        });\n    }\n    if (req.body._id === config.systemEndpointId) {\n        return res.status(400).send({\n            error: 'Name not available'\n        });\n    }\n    if (req.body.email && config.restrictLocalAccountsToDomains && config.restrictLocalAccountsToDomains.length) {\n        var emailParts = req.body.email.toLowerCase().split('@');\n        if (emailParts[1] && config.restrictLocalAccountsToDomains.indexOf(emailParts[1]) === -1) {\n            return res.status(400).send({\n                error: 'You must sign up with an email from of the following domains: ' + config.restrictLocalAccountsToDomains.join(',')\n            });\n        }\n    }\n    req.log.info('trying to create new account', req.body._id);\n    var newAccount = new req.db.Account(req.body);\n    var conf = newAccount.conf;\n    newAccount.save(function (err, account) {\n        if (err) {\n            req.log.error(err);\n            err.status = 400;\n            return next(err);\n        }\n        res.send({ message: 'Account created successfully. Check your email to confirm.'});\n\n        // now send account confirmation email\n        // this can take a little while, so send the email in the background\n        var confirmURI = config.baseURL + '/conf/' + account._id + '/' + newAccount.conf;\n\n        // send email confirmation link if they are allowed in configuration\n        if (config.allowSelfConfirmation) {\n            sendConfirmationEmail();\n\n        }\n        // it is possible that this is the first person to sign up.\n        // if that is the case, they will need to be given a confirmation email.\n        else {\n            req.db.Account.count(function (err, totalAccounts) {\n                if (err) {\n                    req.log.error('Error counting number of accounts', err);\n                    return;\n                }\n                if (totalAccounts === 0) {\n                    sendConfirmationEmail();\n                }\n            });\n        }\n\n        function sendConfirmationEmail() {\n            req.email.sendMail({\n                from: config.email.from,\n                to: account.email,\n                subject: 'Account confirmation - ' + config.name,\n                text: 'Visit the following link to confirm your ' + config.name + ' account. ' + confirmURI\n            }, function (err) {\n                if (err) {\n                    req.log.error('Account confirmation email failed to send.', err, \"Visit link to confirm.\", confirmURI);\n                    return;\n                }\n                req.log.error('Sent account confirmation email', account.email, 'with confirmation link', confirmURI)\n            });\n        }\n\n        account = account.toObject();\n        account.conf = conf;\n\n        req.respoke.groups.publish({\n            groupId: config.systemGroupId,\n            message: JSON.stringify({\n                meta: {\n                    type: 'newaccount',\n                    value: account._id\n                }\n            })\n        }, function (err) {\n            if (err) {\n                req.log.error('failed to send new account notification', err);\n            }\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "?ids=",
                    "description": "Optional comma separated list of ids only you are wanting to list."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "?owner=",
                    "description": "Optional Account._id to limit only to that user's groups."
                }
            ],
            "description": {
                "full": "<p>GET /groups</p>\n<p>List the groups this person can see. (currently all groups!)</p>\n",
                "summary": "<p>GET /groups</p>\n",
                "body": "<p>List the groups this person can see. (currently all groups!)</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "Array of Groups",
            "ignore": false,
            "code": "router.get('/groups', middleware.isAuthorized, function (req, res, next) {\n    if (req.query.ids) {\n        req.db.Group.find()\n        .where('_id').in(req.query.ids.split(','))\n        .exec(handler);\n    }\n    else if (req.query.owner) {\n        req.db.Group.find()\n        .where('owner', req.query.owner)\n        .exec(handler);\n    }\n    else {\n        req.db.Group.find().exec(handler);\n    }\n    function handler(err, groups) {\n        if (err) {\n            return next(err);\n        }\n        res.send(groups);\n    }\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>GET /groups/:id</p>\n<p>Get a specific group object by <code>_id</code>.</p>\n",
                "summary": "<p>GET /groups/:id</p>\n",
                "body": "<p>Get a specific group object by <code>_id</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Group || 404 { error: '' }",
            "ignore": false,
            "code": "router.get('/groups/:_id', middleware.isAuthorized, function (req, res, next) {\n    req.db.Group.findById(req.params._id, function (err, group) {\n        if (err) {\n            return next(err);\n        }\n        if (!group) {\n            return res.status(404).send({ error: 'Group not found by id ' + req.params._id });\n        }\n        res.send(group);\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "_id",
                    "description": "The group name."
                }
            ],
            "description": {
                "full": "<p>POST /groups</p>\n<p>Create a new group. Forces you to be the owner.</p>\n",
                "summary": "<p>POST /groups</p>\n",
                "body": "<p>Create a new group. Forces you to be the owner.</p>\n"
            },
            "isPrivate": false,
            "fires": [
                "newgroup"
            ],
            "returns": "object Group",
            "ignore": false,
            "code": "router.post('/groups', middleware.isAuthorized, function (req, res, next) {\n    req.db.Group.findById(req.body._id).exec(function (err, existingGroup) {\n        if (err) {\n            err.status = 500;\n            return next(err);\n        }\n        if (existingGroup) {\n            err = new Error(\"A group by that name already exists.\");\n            err.status = 400;\n            return next(err);\n        }\n        new req.db.Group({\n            _id: req.body._id,\n            owner: req.user._id\n        })\n        .save(function (err, group) {\n            if (err) {\n                err.status = 400;\n                return next(err);\n            }\n            res.send(group);\n\n            req.respoke.groups.publish({\n                groupId: config.systemGroupId,\n                message: JSON.stringify({\n                    meta: {\n                        type: 'newgroup',\n                        value: group._id\n                    }\n                })\n            }, function (err) {\n                if (err) {\n                    req.log.error('failed to send new account notification', err);\n                }\n            });\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>DELETE /groups</p>\n<p>Remove a group by _id if you own it.</p>\n",
                "summary": "<p>DELETE /groups</p>\n",
                "body": "<p>Remove a group by _id if you own it.</p>\n"
            },
            "isPrivate": false,
            "fires": [
                "removegroup"
            ],
            "returns": "object Group",
            "ignore": false,
            "code": "router.delete('/groups/:id', middleware.isAuthorized, function (req, res, next) {\n    req.db.Group.findById(req.params.id, function (err, group) {\n        if (err) {\n            return next(err);\n        }\n        if (!group) {\n            return res.status(404).send({ error: 'Group not found by id ' + req.params.id });\n        }\n        if (group.owner.toString() !== req.user._id.toString()) {\n            return res.status(401).send({ error: 'Unable to remove group that does not belong to you.' });\n        }\n\n        // kick everyone out first\n        req.respoke.groups.publish({\n            groupId: config.systemGroupId,\n            message: JSON.stringify({\n                meta: {\n                    type: 'removegroup',\n                    value:  group._id\n                }\n            })\n        }, function (err) {\n            if (err) {\n                req.log.error('failed to send new account notification', err);\n            }\n        });\n\n        async.series([\n            function (cb) {\n                req.db.Message.distinct('file', {\n                    group: req.params.id\n                })\n                .exec(function (err, ids) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    req.db.File.remove({\n                        _id: { $in: ids }\n                    })\n                    .exec(cb);\n                });\n            },\n            function (cb) {\n                req.db.Message.remove({\n                    group: req.params.id\n                })\n                .exec(function (err) {\n                    if (err) {\n                        return cb(err);\n                    }\n                    cb();\n                });\n            },\n            function (cb) {\n                group.remove(cb);\n            }\n        ], function (err) {\n            if (err) {\n                return next(err);\n            }\n            res.send({ message: 'Group was removed successfully.' });\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>PATCH /groups/:_id/owner/:accountId</p>\n<p>Change ownership of a group (param <code>_id</code>).</p>\n<p>New owner is the <code>Account._id</code> in URL param <code>accountId</code>.</p>\n",
                "summary": "<p>PATCH /groups/:_id/owner/:accountId</p>\n",
                "body": "<p>Change ownership of a group (param <code>_id</code>).</p>\n<p>New owner is the <code>Account._id</code> in URL param <code>accountId</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Group",
            "ignore": false,
            "code": "router.patch('/groups/:_id/owner/:accountId', middleware.isAuthorized, function (req, res, next) {\n    req.db.Group\n    .findById(req.params._id)\n    .populate('owner')\n    .exec(function (err, group) {\n        if (err) {\n            return next(err);\n        }\n        if (!group) {\n            return res.status(404).send({ error: 'Group ' + req.params._id + ' was not found.' });\n        }\n        if (group.owner._id.toString() !== req.user._id.toString()) {\n            return res.status(401).send({\n                error: 'Group ' + req.params._id + ' is owned by ' + group.owner.display + '.'\n            });\n        }\n        req.db.Account.findById(req.params.accountId, function (err, account) {\n            if (err) {\n                return next(err);\n            }\n            if (!account) {\n                return res.status(404).send({ error: \"Account \" + req.params.accountId + \" does not exist.\"});\n            }\n            group.owner = req.params.accountId;\n            group.save(function (err, group) {\n                if (err) {\n                    return next(err);\n                }\n                res.send(group);\n            });\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "?ids=",
                    "description": "Comma separated list of `Message._id`s."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "?group=",
                    "description": "`Message.group` of the messages."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "?account=",
                    "description": "Messages between the logged in user and another account."
                },
                {
                    "type": "arg",
                    "types": [
                        "number"
                    ],
                    "name": "?limit=50",
                    "description": "Integer; how many messages to fetch."
                },
                {
                    "type": "arg",
                    "types": [
                        "number"
                    ],
                    "name": "?skip=0",
                    "description": "Integer; how many messages to skip when fetching (descending order by created)."
                },
                {
                    "type": "arg",
                    "types": [
                        "date"
                    ],
                    "name": "?before=",
                    "description": "Fetch messages that were created no later than this date."
                }
            ],
            "description": {
                "full": "<p>GET /messages</p>\n<p>Fetch messages. Requires one or more querystring params to determine what you need.</p>\n<p>Always sorts <em>descending by <code>created</code></em> (most recent are last).</p>\n<p>The following properties are <strong>populated</strong> with the objects, instead of being\njust an _id field:</p>\n<ul>\n<li><code>message.from</code></li>\n<li><code>message.to</code></li>\n<li><code>message.group</code></li>\n</ul>\n",
                "summary": "<p>GET /messages</p>\n",
                "body": "<p>Fetch messages. Requires one or more querystring params to determine what you need.</p>\n<p>Always sorts <em>descending by <code>created</code></em> (most recent are last).</p>\n<p>The following properties are <strong>populated</strong> with the objects, instead of being\njust an _id field:</p>\n<ul>\n<li><code>message.from</code></li>\n<li><code>message.to</code></li>\n<li><code>message.group</code></li>\n</ul>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "Array of Messages",
            "ignore": false,
            "code": "router.get('/messages', middleware.isAuthorized, function (req, res, next) {\n\n    // Build a message query.\n    // Always sorted descending by created.\n\n    var DEFAULT_LIMIT = 50;\n\n    var query = req.db.Message.find().sort('-created');\n\n    // specific message _id list\n    if (req.query.ids) {\n        query = query.where('_id').in(req.query.ids.split(','));\n    }\n\n    // messages for a group\n    if (req.query.group) {\n        query = query.where('group', req.query.group);\n    }\n\n    // messages between two accounts\n    if (req.query.account) {\n        query = query.or([\n            { to: req.query.account,   from: req.user._id },\n            { from: req.query.account, to: req.user._id }\n        ]);\n    }\n\n    // limit\n    if (req.query.limit) {\n        query = query.limit(req.query.limit);\n    }\n    else {\n        query = query.limit(DEFAULT_LIMIT);\n    }\n\n    // skip\n    if (req.params.skip) {\n        query = query.skip(req.query.skip);\n    }\n\n    if (req.query.before) {\n        query = query.where('created').lt(req.query.before);\n    }\n\n    query\n    .populate('from to group')\n    .exec(function (err, messages) {\n        if (err) {\n            return next(err);\n        }\n        res.send(messages);\n    });\n\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "to",
                    "description": "Optional Account._id for a private message."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "group",
                    "description": "Optional Group._id for a group message."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "content",
                    "description": "The message text."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "file",
                    "description": "Optional File._id that is considered related to this message."
                }
            ],
            "description": {
                "full": "<p>POST /messages</p>\n<p>Create a message which persists it to the server.</p>\n<p>Does not send it through Respoke as a web socket. That is done by the client.</p>\n",
                "summary": "<p>POST /messages</p>\n",
                "body": "<p>Create a message which persists it to the server.</p>\n<p>Does not send it through Respoke as a web socket. That is done by the client.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Message",
            "ignore": false,
            "code": "router.post('/messages', middleware.isAuthorized, function (req, res, next) {\n    if (req.body.content && req.body.content.length > 4096) {\n        var err = new Error('Message is too long. Consider breaking it into smaller chunks.');\n        err.status = 400;\n        return next(err);\n    }\n    new req.db.Message({\n        from: req.user._id,\n        to: req.body.to,\n        group: req.body.group,\n        content: req.body.content,\n        file: req.body.file\n    }).save(function (err, message) {\n        if (err) return next(err);\n\n        //\n        // Response to client is here.\n        //\n        res.send(message);\n\n\n        var content;\n        try {\n            content = JSON.parse(req.body.content);\n        }\n        catch (ex) {\n            return;\n        }\n\n        // send offline notification email\n        if (req.body.recipientOffline) {\n            if (req.body.file) {\n                return;\n            }\n            req.db.Account.findById(req.body.to).exec(function (err, account) {\n                if (err) {\n                    req.log.error(err);\n                }\n                if (!account) {\n                    return;\n                }\n                if (!account.settings.offlineNotifications) {\n                    return;\n                }\n\n                var emailContent = {\n                    from: config.email.from,\n                    replyTo: req.user.email,\n                    to: account.email,\n                    subject: '[' + config.name + '] '\n                        + req.user.display + ' sent you a message while you were offline',\n                    text: req.user.display + ' said:\\n\\n' + content.text\n                        + '\\n---\\nUnsubscribe from these messages in the '\n                        + config.name + ' settings. '\n                        + config.baseURL\n                };\n\n                if (account.settings.htmlEmails) {\n                    emailContent.html = '<em>' + req.user.display + '</em>&nbsp;&nbsp;&nbsp;'\n                        + content.text\n                        + '<br />---<br /><a href=\"' + config.baseURL + '\">'\n                        + 'Unsubscribe from these messages in the '\n                        + config.name + ' settings</a>';\n                }\n\n                req.email.sendMail(emailContent, function (err) {\n                    if (err) {\n                        req.log.error(err);\n                        return;\n                    }\n                    req.log.info('offline conversation email sent', req.user.email, account.email);\n                });\n            });\n        }\n\n        // send offline mention email, but only for groups.\n        if (req.body.group && req.body.offlineMentions) {\n            var mentions = req.body.offlineMentions instanceof Array ? req.body.offlineMentions : req.body.offlineMentions.split(',');\n\n            req.db.Account.find().where('_id').in(mentions).exec(function (err, accounts) {\n                if (err) {\n                    req.log.error(err);\n                    return;\n                }\n\n                accounts.forEach(function sendNotifEmail(account) {\n                    if (!account) {\n                        return;\n                    }\n\n                    var emailContent = {\n                        from: config.email.from,\n                        replyTo: req.user.email,\n                        to: account.email,\n                        subject: '[' + config.name + '] '\n                            + req.user.display + ' mentioned you in ' + req.body.group,\n                        text: req.user.display + ' said:\\n\\n' + content.text\n                            + '\\n---\\n'\n                            + config.name + '   '\n                            + config.baseURL\n                    };\n\n                    if (account.settings.htmlEmails) {\n                        emailContent.html = '<em>' + req.user.display + '</em>&nbsp;&nbsp;&nbsp;'\n                            + content.text\n                            + '<br />---<br /><a href=\"' + config.baseURL + '\">'\n                            + config.name + '</a>';\n                    }\n\n                    req.email.sendMail(emailContent, function (err) {\n                        if (err) {\n                            req.log.error(err);\n                            return;\n                        }\n                        req.log.info('offline mention email sent', req.user.email, account.email);\n                    });\n                });\n            });\n        }\n\n\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "content",
                    "description": "The file as Base64 encoded string."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "contentType",
                    "description": "MIME type of the file."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "owner",
                    "description": "The Account._id of the logged in user uploading the file."
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "name",
                    "description": "Optional file name."
                }
            ],
            "description": {
                "full": "<p>POST /files</p>\n<p>Upload a file.</p>\n",
                "summary": "<p>POST /files</p>\n",
                "body": "<p>Upload a file.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object File (model - not actual file)",
            "ignore": false,
            "code": "router.post('/files', middleware.isAuthorized, function (req, res, next) {\n    var contentType = req.body.contentType || 'text/plain';\n\n    new req.db.File({\n        content: req.body.content,\n        contentType: contentType,\n        name: req.body.name,\n        owner: req.user._id\n    }).save(function (err, file) {\n        if (err) {\n            return next(err);\n        }\n        res.send(file);\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>GET /files/:_id</p>\n<p>Fetch an entire File document.</p>\n<p>Get <em>only</em> the file by doing <code>GET /files/:_id</code>.</p>\n",
                "summary": "<p>GET /files/:_id</p>\n",
                "body": "<p>Fetch an entire File document.</p>\n<p>Get <em>only</em> the file by doing <code>GET /files/:_id</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object File",
            "ignore": false,
            "code": "router.get('/files/:_id', middleware.isAuthorized, function (req, res, next) {\n    req.db.File.findById(req.params._id, function (err, file) {\n        if (err) {\n            return next(err);\n        }\n        if (!file) {\n            return res.status(404).send({ error: 'Not found'});\n        }\n        res.send(file);\n    });\n});\n\nmodule.exports = router;",
            "ctx": {
                "file": {
                    "input": "routes/api.js",
                    "output": "docs/routes/api.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The AGPL v3 License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The AGPL v3 License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": true,
            "code": "var express = require('express');",
            "ctx": {
                "type": "declaration",
                "name": "express",
                "value": "require('express')",
                "string": "express",
                "file": {
                    "input": "routes/auth.js",
                    "output": "docs/routes/auth.js.json"
                }
            }
        }
    ],
    "auth": [
        {
            "tags": [
                {
                    "type": "class",
                    "string": "auth"
                }
            ],
            "description": {
                "full": "<p>Router attached at <code>/auth</code>.</p>\n",
                "summary": "<p>Router attached at <code>/auth</code>.</p>\n",
                "body": ""
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "var router = express.Router();\nvar passport = require('passport');\nvar middleware = require('../lib/middleware');\nvar config = require('../config');",
            "ctx": {
                "type": "declaration",
                "name": "auth",
                "value": "express.Router()",
                "string": "router",
                "file": {
                    "input": "routes/auth.js",
                    "output": "docs/routes/auth.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>DELETE /session</p>\n<p>Log out</p>\n",
                "summary": "<p>DELETE /session</p>\n",
                "body": "<p>Log out</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object { message: '' }",
            "ignore": false,
            "code": "router.delete('/session', function (req, res) {\n    req.logout();\n    res.send({ message: 'Logged out' });\n});",
            "ctx": {
                "file": {
                    "input": "routes/auth.js",
                    "output": "docs/routes/auth.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>GET /tokens</p>\n<p>Fetch a Respoke token brokered authentication. Endpoint ID is automatically assigned\nas the logged in user <code>Account._id</code>.</p>\n",
                "summary": "<p>GET /tokens</p>\n",
                "body": "<p>Fetch a Respoke token brokered authentication. Endpoint ID is automatically assigned\nas the logged in user <code>Account._id</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object {\n token: '',\n appId: '',\n baseURL: '',\n systemGroupId: '',\n systemEndpointId: ''\n }",
            "ignore": false,
            "code": "router.get('/tokens', middleware.isAuthorized, function (req, res, next) {\n    var authSettings = {\n        endpointId: req.user._id,\n        roleId: config.respoke.roleId\n    };\n    // return next(new Error('testing'));\n\n    req.respoke.auth.endpoint(authSettings, function (err, authData) {\n        if (err) {\n            req.log.error('auth.endpoint', err);\n            return next(new Error(\"Failed to get connection credentials for the chat provider.\"));\n        }\n\n        if (!authData || !authData.tokenId) {\n            req.log.error('invalid response from Respoke auth.endpoint method', authData);\n            return next(new Error(\"Invalid response from server. Please try again later.\"));\n        }\n\n        res.send({\n            token: authData.tokenId,\n            appId: req.respoke.appId,\n            baseURL: config.respoke.baseURL,\n            systemGroupId: config.systemGroupId,\n            systemEndpointId: config.systemEndpointId\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/auth.js",
                    "output": "docs/routes/auth.js.json"
                }
            }
        },
        {
            "tags": [
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "email",
                    "description": "Account._id or email address"
                },
                {
                    "type": "arg",
                    "types": [
                        "string"
                    ],
                    "name": "password",
                    "description": ""
                }
            ],
            "description": {
                "full": "<p>POST /local</p>\n<p>Local login.</p>\n",
                "summary": "<p>POST /local</p>\n",
                "body": "<p>Local login.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "returns": "object Account",
            "ignore": false,
            "code": "router.post('/local', function (req, res, next) {\n    if (typeof req.body.email !== 'string') {\n        return res.status(400).send({ message: 'Missing email or username.'});\n    }\n    req.db.Account.findOne()\n    .or([{ _id: req.body.email.toLowerCase() }, { email: req.body.email.toLowerCase() }])\n    .select('+password +conf')\n    .exec(function (err, account) {\n        if (err) {\n            return next(err);\n        }\n        if (!account) {\n            return res.status(400).send({ message: 'Incorrect username.' });\n        }\n        if (account.conf && account.conf.slice(0, 7) === 'confirm') {\n            return res.status(400).send({\n                message: 'Your account must be confirmed before you may log in.'\n            });\n        }\n        if (!account.password) {\n            return res.status(401).send({\n                message: 'A password has not been set for this account yet.'\n            });\n        }\n        var hashedPassword = req.utils.hash(req.body.password);\n        if (hashedPassword !== account.password) {\n            return res.status(401).send({ message: 'Incorrect password.' });\n        }\n        account = account.toObject();\n        delete account.password;\n        req.login(account, function (err) {\n            if (err) {\n                return next(err);\n            }\n            res.send(req.user);\n        });\n    });\n});",
            "ctx": {
                "file": {
                    "input": "routes/auth.js",
                    "output": "docs/routes/auth.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>GET /google</p>\n<p>Typically you would visit this page from a web browser.</p>\n<p>Redirect the user to Google for authentication.  When complete, Google\nwill redirect the user back to the application at <code>/auth/google/callback</code>.</p>\n",
                "summary": "<p>GET /google</p>\n",
                "body": "<p>Typically you would visit this page from a web browser.</p>\n<p>Redirect the user to Google for authentication.  When complete, Google\nwill redirect the user back to the application at <code>/auth/google/callback</code>.</p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": false,
            "code": "router.get(\n    '/google',\n    passport.authenticate('google', {\n        scope: [\n            'https://www.googleapis.com/auth/userinfo.profile',\n            'https://www.googleapis.com/auth/userinfo.email'\n        ]\n    })\n);\nrouter.get('/google/callback', passport.authenticate('google', {\n    failureRedirect: '/#/welcome?authFailure=Google+auth+failed'\n}), function (req, res) {\n    res.redirect('/');\n});\n\nmodule.exports = router;",
            "ctx": {
                "file": {
                    "input": "routes/auth.js",
                    "output": "docs/routes/auth.js.json"
                }
            }
        },
        {
            "tags": [],
            "description": {
                "full": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n<p>This source code is licensed under The AGPL v3 License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n",
                "summary": "<p>Copyright 2014, Digium, Inc.\nAll rights reserved.</p>\n",
                "body": "<p>This source code is licensed under The AGPL v3 License found in the\nLICENSE file in the root directory of this source tree.</p>\n<p>For all details and documentation:  <a href=\"https://www.respoke.io\">https://www.respoke.io</a></p>\n"
            },
            "isPrivate": false,
            "fires": [],
            "ignore": true,
            "code": "var express = require('express');\nvar router = express.Router();\nvar config = require('../config');\nvar middleware = require('../lib/middleware');\n\nrouter.get('/', function (req, res) {\n    req.log.info('saying something here');\n    res.render('index', { title: config.name });\n});\n\nrouter.get('/private', middleware.isAuthorized, function (req, res) {\n    res.render('call', {\n        title: 'Video call'\n    });\n});\n\nrouter.get('/files/:id', middleware.isAuthorized, function (req, res, next) {\n    req.db.File.findById(req.params.id, function (err, file) {\n        if (err) {\n            return next(err);\n        }\n        if (!file) {\n            return res.status(404).send({ error: 'Not found'});\n        }\n        res.set('Content-Type', file.contentType);\n        res.send(new Buffer(file.content, 'base64'));\n    });\n});\n\nrouter.get('/conf/:_id/:conf', function (req, res, next) {\n    req.db.Account\n    .findOne({ _id: req.params._id, conf: req.params.conf })\n    .exec(function (err, account) {\n        var genericMessage = new Error(\"Invalid ID or confirmation code. It may have already been used.\");\n        genericMessage.status = 404;\n        if (err) {\n            req.log.error('confirmation error', err);\n            return next(genericMessage);\n        }\n        if (!account) {\n            return next(genericMessage);\n        }\n        account.conf = null;\n        account.save(function (err, saved) {\n            if (err) {\n                return next(err);\n            }\n\n            res.render('conf', {\n                title: 'Email confirmed',\n                message: 'Welcome!'\n            });\n\n            req.respoke.groups.publish({\n                groupId: config.systemGroupId,\n                message: JSON.stringify({\n                    meta: {\n                        type: 'newaccount',\n                        value: account._id\n                    }\n                })\n            }, function (err) {\n                if (err) {\n                    req.log.error('failed to send new account notification', err);\n                }\n            });\n\n        });\n    });\n});\n\nrouter.get('/password-reset/:_id/:conf', function(req, res, next) {\n    req.db.Account\n    .findOne({ _id: req.params._id, conf: req.params.conf })\n    .select('+conf')\n    .exec(function (err, account) {\n        var genericMessage = new Error(\"Invalid ID or reset code.\");\n        genericMessage.status = 404;\n        if (err) {\n            req.log.error('password reset error', err);\n            return next(genericMessage);\n        }\n        if (!account) {\n            return next(genericMessage);\n        }\n        res.render('reset', {\n            title: 'Password reset',\n            message: 'Reset your password',\n            conf: account.conf,\n            _id: account._id\n        });\n    });\n});\n\nmodule.exports = router;",
            "ctx": {
                "type": "declaration",
                "name": "express",
                "value": "require('express')",
                "string": "express",
                "file": {
                    "input": "routes/home.js",
                    "output": "docs/routes/home.js.json"
                }
            }
        }
    ]
}